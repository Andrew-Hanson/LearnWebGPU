# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022-2023, Ã‰lie Michel and contributors
# This file is distributed under the same license as the Learn WebGPU for
# C++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Learn WebGPU for C++ \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-25 09:12+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ko\n"
"Language-Team: ko <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../../advanced-techniques/benchmarking/environmental-impact.md:1
msgid "Environmental Impact (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/benchmarking/environmental-impact.md:4
msgid ""
"It is important to be able to asses, at least roughly, the environmental "
"impact of an application, if we want to be able to compare with other "
"(potentially non-software based) solution to the problem they address."
msgstr ""

#: ../../advanced-techniques/benchmarking/environmental-impact.md:6
msgid ""
"GPU-intensive application have an environmental impact through multiple "
"expenses, for instance:"
msgstr ""

#: ../../advanced-techniques/benchmarking/environmental-impact.md:8
msgid ""
"The impact of the energy expense while using the application depends on "
"how long computation run, how long the user uses intensive computations "
"in a typical workflow, how intense the computation is."
msgstr ""

#: ../../advanced-techniques/benchmarking/environmental-impact.md:10
msgid ""
"The choice of minimal required limits impacts the need to manufacture new"
" hardware."
msgstr ""

#: ../../advanced-techniques/benchmarking/environmental-impact.md:12
msgid ""
"Tools for measuring **instant energy** expense depend a lot on the "
"platform. For instance NVidia provides information through the [NVML "
"library](https://developer.nvidia.com/nvidia-management-library-nvml)."
msgstr ""

#: ../../advanced-techniques/benchmarking/environmental-impact.md:14
msgid ""
"The **carbon impact** of this energy depends on the user's location. "
"Several APIs exist to query this information, like "
"[WattTime](https://www.watttime.org/api-documentation)."
msgstr ""

#: ../../advanced-techniques/benchmarking/environmental-impact.md:16
msgid ""
"The **manufacturing impact** is harder to evaluate, especially for non-"
"carbon related, which includes notably the challenging extraction of "
"**rare metals**, which are non-renewable."
msgstr ""

#: ../../advanced-techniques/benchmarking/index.md:1
msgid "Benchmarking"
msgstr ""

#: ../../advanced-techniques/benchmarking/index.md:4
msgid ""
"Benchmarking consists in measuring the **resources** needed for different"
" tasks, in order for instance to identify **performance bottlenecks** or "
"to compare two approaches to the same problem."
msgstr ""

#: ../../advanced-techniques/benchmarking/index.md:6
#: ../../advanced-techniques/index.md:4
msgid "Contents"
msgstr ""

#: ../../advanced-techniques/benchmarking/memory.md:1
msgid "Memory (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/benchmarking/processing-units.md:1
msgid "Processing Units (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:1
msgid "Time"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:5
#: ../../advanced-techniques/benchmarking/time.md:697
msgid ""
"*Resulting code:* [`step095-timestamp-"
"queries`](https://github.com/eliemichel/LearnWebGPU-Code/tree/step095"
"-timestamp-queries)"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:9
#: ../../advanced-techniques/benchmarking/time.md:701
msgid ""
"*Resulting code:* [`step095-timestamp-queries-"
"vanilla`](https://github.com/eliemichel/LearnWebGPU-Code/tree/step095"
"-timestamp-queries-vanilla)"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:12
msgid ""
"We start by **measuring compute time**, which is often the most valuable "
"resource."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:15
msgid ""
"As of September 6, 2023, wgpu-native does not support timestamp queries "
"yet. I suggest you follow this chapter with Dawn only for now."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:18
msgid "Asynchronicity"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:21
msgid ""
"Importantly, measuring GPU time is **quite different** from measuring CPU"
" time, because as you may recall **we only interact with the GPU through "
"remote calls** issued in our CPU code (C++)."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:23
msgid "In an imperative CPU code, measuring time looks like this:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:33
msgid ""
"But when doing this on the GPU, we only **submit** operations that run on"
" a **different timeline**:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:43
msgid ""
"The \"something\" may not even have started at this point. What we "
"measure is the time it takes to submit instructions, **not to actually "
"execute them**!"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:45
msgid "Timestamp Queries"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:48
msgid ""
"We must instruct the GPU to run some equivalent of `get_current_time()` "
"on its own timeline. The result of this operation is stored in a "
"dedicated object called a **timestamp query**."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:59
msgid ""
"We must then **fetch** the timestamp values back to the CPU, through a "
"mapped buffer like we see in [Playing with buffers](../../basic-3d-"
"rendering/input-geometry/playing-with-buffers.md#mapping-context)."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:61
msgid "ðŸ«¡ Okey, got it, so what about actual C++ code?"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:63
msgid ""
"Whether they measure timestamps or other things, GPU queries are stored "
"in a `QuerySet`. We typically store both the start and end time in the "
"same set:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:87
msgid ""
"I base this example on [`step095`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step095), from chapter [Simple GUI](../../basic-"
"3d-rendering/some-interaction/simple-gui.md)"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:91
msgid ""
"I created a `initBenchmark()` method (called in `onInit`) to initialize "
"benchmark-related objects like the query set. I also created a "
"`terminateBenchmark()` to release these resources."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:94
msgid ""
"However, if you try to add the code block above to your application, you "
"will face an error:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:96
msgid ""
"**Device error:** *(Dawn)* Timestamp queries are disallowed because they "
"may expose precise timing information. *(wgpu-native)* "
"Features(TIMESTAMP_QUERY) are required but not enabled on the device."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:100
msgid "Enabling Timestamp Feature"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:103
msgid "Dawn toggles"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:105
msgid ""
"Let us start with Dawn: for **privacy reasons**, Dawn disables timing "
"information. This is relevant when running on the Web, but not in our "
"native application context. Fortunately, **this safeguard can easily be "
"disabled**."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:107
msgid ""
"Dawn has a list of so-called \"toggles\" that can be turned on or off at "
"the scale of the whole WebGPU instance: the list is available in "
"[`Toggles.cpp`](https://dawn.googlesource.com/dawn/+/refs/heads/main/src/dawn/native/Toggles.cpp#33)."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:109
msgid ""
"To enable toggles, we use the Dawn-specific `DawnTogglesDescriptor` "
"**extension**, which can be chained to the instance descriptor:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:139
msgid "We then specify that we want to enable the `allow_unsafe_apis` feature:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:180
msgid ""
"The toggles descriptor can also be used as an extension of the adapter or"
" device request options. In that case, device toggles supersede adapter "
"toggles, which supersede instance toggles."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:183
msgid "The error message we get is now slightly different:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:185
msgid ""
"**Device error:** *(Dawn)* Timestamp query set created without the "
"feature being enabled."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:188
msgid ""
"This is in substance the same error than the one reported by `wgpu-"
"native` above, we treat both in the next section."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:190
msgid "Feature request"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:192
msgid ""
"When creating our WebGPU device, we mentioned already that we can set up "
"specific limits. But we can also **request specific features** from the "
"`WGPUFeatureName` enum. In particular, we need to enable "
"`FeatureName::TimestampQuery`."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:214
msgid ""
"The error messages should now be fixed! You may also want to check that "
"the adapter, and then the device, support this feature:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:243
msgid ""
"Timestamp queries are specified as an explicit feature because some "
"devices/adapters may not support them."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:246
msgid "Writing timestamps"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:249
msgid ""
"There are different ways of writing timestamp into queries. The closest "
"one to our pseudocode above is `commandEncoder.writeTimestamp()`, which "
"writes the GPU-side time into a query whenever the command is executed in"
" the **GPU timeline**."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:251
msgid ""
"If you want more specifically to measure the time taken by **a render or "
"compute pass**, you can also pass timestamp queries to the passes "
"descriptor:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:288
msgid ""
"I initialize the query set only once and store it into an attribute "
"`m_timestampQueries` of the `Application` class."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:291
msgid "Reading timestamps"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:294
msgid "Resolving timestamps"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:296
msgid ""
"Okey, the render pass writes to our first query when it begins, and "
"writes to the second query when it ends. We only need to compute the "
"difference now, right? But the timestamps still **live in the GPU "
"memory**, so we first need to **fetch them back** to the CPU."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:298
msgid ""
"The first step consists in **resolving** the query. This gets the "
"timestamp values from whatever internal representation the WebGPU "
"implementation uses to store query set and write them in a **GPU "
"buffer**."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:331
msgid ""
"And as you noticed we need to create a dedicated buffer "
"`m_timestampResolveBuffer` with the `QueryResolve` usage. This buffers "
"needs to reserve a **64-bit unsigned integer** per timestamp:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:373
msgid ""
"One the Web, the timestamp resolution may include rounding the value, to "
"avoid giving access to precise information that could lead to timing "
"attacks."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:376
msgid ""
"We can call `resolveTimestamps` in our main loop, after "
"`renderPass.end()` and before `encoder.finish()`:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:396
msgid ""
"At this stage, if we only process the timestamps on the GPU, this is all "
"we need. We can for instance provide them as uniforms in a shader."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:398
msgid "Fetching timestamps"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:400
msgid ""
"But usually we need to read timestamps on the CPU (for instance to "
"display them with ImGui)."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:402
msgid ""
"We cannot directly map the resolve buffer, because buffers that have the "
"`MapRead` usage can only be used for mapping. We thus create another "
"buffer, namely the `m_timestampMapBuffer`:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:444
msgid "We then copy to this buffer right after resolution:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:477
msgid ""
"And finally we map this buffer. But we must take care of doing this "
"**after the encoder has been submitted**, because it is not allowed to "
"copy to a buffer while it is being mapped. We thus create a new "
"`fetchTimestamps()` method, called after `queue.submit()`:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:499
msgid ""
"Also, remember that **buffer mapping is asynchronous**, so we must be "
"careful when this `fetchTimestamps()` function is called at each frame."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:502
msgid ""
"This part differs slightly in architecture depending on whether you are "
"using the C++ wrapper or the vanilla API, I invite you to pick the right "
"tab below:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:506
#: ../../advanced-techniques/benchmarking/time.md:558
msgid ""
"Overall the mapping operation looks like what we did in the [Playing with"
" buffers](../../basic-3d-rendering/input-geometry/playing-with-"
"buffers.md) chapter:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:523
msgid ""
"However to ensure that the callback **outlives the scope** in which it is"
" defined here, we must maintain its handle in the `Application` class:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:533
msgid ""
"Lastly, we **do not want to trigger a new mapping operation** if there is"
" already one going on! To check this, we may simply use the handle and "
"**return early** whenever it is not null:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:553
msgid "TODO:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:554
msgid "Define a static method to be used as callback"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:555
msgid "Add a boolean to check whether there is an ongoing mapping operation"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:586
msgid ""
"However, we **do not want to trigger a new mapping operation** if there "
"is already one going on! To check this, we add a simple boolean attribute"
" and **return early** whenever a mapping operation is already in flight:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:610
msgid ""
"Thanks to this, we can now safely call `fetchTimestamps()` at each frame,"
" right after submitting the command buffer."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:612
msgid "Using timestamp values"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:615
msgid "Display"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:617
msgid ""
"We can finally manipulate timestamp values on the CPU! At first we can "
"**display them** in the terminal: in the map callback, when mapping was "
"successful:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:628
msgid "You get in the end a little less than 1 log line per frame:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:645
msgid "Statistics"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:647
msgid ""
"Usually, I am not interested in one line per frame, but rather in showing"
" in the UI the **mean** and **standard deviation** of my measure. I use "
"for this my "
"[`TinyTimer.h`](https://gist.github.com/eliemichel/54912bdafb8d16b21b0e7d9fce73a845):"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:670
msgid "Our GPU timer displayed in the application."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:674
msgid ""
"In this example, we can see that the render pass takes much less time "
"than a frame. This is because the limiting factor here is the **VSync** "
"that caps the number of frames per second to 60 (the maximum refresh rate"
" of my display)."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:678
msgid ""
"When reporting and comparing benchmark values, and statistics in general,"
" it is important to look at the **standard deviation**, but also at the "
"**number of samples** on which this standard value is estimated."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:681
#: ../../advanced-techniques/hdr-textures.md:197
#: ../../advanced-techniques/raii.md:225
msgid "Conclusion"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:684
msgid ""
"You are now able to use precise GPU-side timers, which is essential to "
"evaluate the performances of your application and identify the "
"bottlenecks. Remember that:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:686
msgid "GPU timers don't live on the same **timeline** as CPU timers."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:687
msgid ""
"You need to create timestamp queries, then **write** to them, **resolve**"
" them, and finally **fetch** them back asynchronously."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:688
msgid ""
"You must pay attention not to fetch before the resolve/copy operations "
"are not only encoded by **submitted** to the GPU."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:690
msgid ""
"I would suggest to create a little class responsible solely for managing "
"the timers in your application, so that the boilerplate is isolated to "
"your application's logic."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:693
msgid ""
"If you want to measure performances for events that do **not happen at "
"each frame**, you should keep for each such counter a **boolean** telling"
" whether the counter has been updated, so that you `add_sample` upon "
"fetch callback only when the timestamps were **actually updated**."
msgstr ""

#: ../../advanced-techniques/deferred-shading.md:1
msgid "Deferred Shading (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:1
msgid "High Dynamic Range Textures (ðŸš§WIP)"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:5
#: ../../advanced-techniques/hdr-textures.md:201
msgid ""
"*Resulting code:* [`step120`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step120)"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:9
#: ../../advanced-techniques/hdr-textures.md:205
msgid ""
"*Resulting code:* [`step120-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step120-vanilla)"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:12
msgid ""
"*(NB: This used to be placed right after [Image-Based Lighting](../basic-"
"3d-rendering/lighting-and-material/ibl.md))*"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:14
msgid "High Dynamic Range"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:17
msgid "Load [`autumn_park_4k.exr`](../data/autumn_park_4k.exr):"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:23
msgid ""
"Since stb_image, the library we use to load PNGs, does not know EXR file,"
" we use [tinyexr](https://github.com/syoyo/tinyexr), which is integrated "
"in a similar spirit to our other dependencies."
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:25
msgid ""
"Download "
"[`tinyexr.h`](https://github.com/syoyo/tinyexr/raw/02310c77e5156c36fedf6cf810c4071e3f83906f/tinyexr.h),"
" "
"[`miniz.c`](https://raw.githubusercontent.com/syoyo/tinyexr/02310c77e5156c36fedf6cf810c4071e3f83906f/deps/miniz/miniz.c)"
" and "
"[`miniz.h`](https://raw.githubusercontent.com/syoyo/tinyexr/02310c77e5156c36fedf6cf810c4071e3f83906f/deps/miniz/miniz.h)"
" into your source tree and add the following to `implementations.cpp`:"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:32
msgid ""
"Also add `miniz.c` and (optionally) `miniz.h`/`tinyexr.h` to the "
"CMakeLists:"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:43
msgid "We also need some more tuning to our CMakeLists:"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:55
msgid ""
"In the resource manager, we create a copy of `loadTexture` called "
"`loadExrTexture` where we use TinyEXR instead of stb_image and load data "
"as float rather than 8-bit integers, which affects the creation of "
"mipmaps:"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:110
msgid ""
"Note that in order to avoid duplicating the mip-map creation part, I "
"isolated this templated utility function:"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:177
msgid ""
"All there is to do now is call in `initTexture` one or the other of these"
" loading functions depending on the file extension:"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:192
msgid ""
"The [texture format capabilities table](https://www.w3.org/TR/webgpu"
"/#texture-format-caps) shows that in order to allow filtering for float32"
" textures, we need to enable the `float32-filterable` **feature** when "
"creating the device."
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:195
msgid ""
"We use [`float16_t.hpp`](../data/float16_t.hpp) because C++ does not have"
" a 16-bit float type out of the box."
msgstr ""

#: ../../advanced-techniques/headless.md:1
msgid "Headless context"
msgstr ""

#: ../../advanced-techniques/headless.md:5
#: ../../advanced-techniques/headless.md:304
msgid ""
"*Resulting code:* [`step030-headless`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step030-headless)"
msgstr ""

#: ../../advanced-techniques/headless.md:9
#: ../../advanced-techniques/headless.md:308
msgid ""
"*Resulting code:* [`step030-headless-"
"vanilla`](https://github.com/eliemichel/LearnWebGPU-Code/tree/step030"
"-headless-vanilla)"
msgstr ""

#: ../../advanced-techniques/headless.md:12
msgid ""
"Sometimes, one needs to use the GPU **without opening a window** at all. "
"This is quite easy to do with WebGPU!"
msgstr ""

#: ../../advanced-techniques/headless.md:15
msgid ""
"The code of this chapter is based on the "
"[`step030`](https://github.com/eliemichel/LearnWebGPU-Code/tree/step030) "
"from [Hello Triangle](../basic-3d-rendering/hello-triangle.md)."
msgstr ""

#: ../../advanced-techniques/headless.md:18
msgid ""
"In our *Hello Triangle* code, WebGPU interacts with the window in only "
"two places:"
msgstr ""

#: ../../advanced-techniques/headless.md:20
msgid "When creating the adapter."
msgstr ""

#: ../../advanced-techniques/headless.md:21
msgid "When setting up the swap chain."
msgstr ""

#: ../../advanced-techniques/headless.md:23
msgid "Adapter creation"
msgstr ""

#: ../../advanced-techniques/headless.md:26
msgid ""
"Our first change consists in replacing the `compatibleSurface` of the "
"adapter options to `nullptr`:"
msgstr ""

#: ../../advanced-techniques/headless.md:47
msgid "Swap Chain"
msgstr ""

#: ../../advanced-techniques/headless.md:50
msgid ""
"The swap chain is a mechanism meant to seamlessly display rendered images"
" on the window. When we no longer have a window... we simply **no longer "
"need a swap chain**!"
msgstr ""

#: ../../advanced-techniques/headless.md:76
msgid ""
"In the main render loop (which may not be a loop in a headless use case "
"by the way) we need to **manage the target texture view** ourselves "
"instead of using `swapChain.getCurrentTextureView()`."
msgstr ""

#: ../../advanced-techniques/headless.md:92
msgid "Target texture"
msgstr ""

#: ../../advanced-techniques/headless.md:94
msgid ""
"We now create the texture to render into, for instance where we used to "
"create the swap chain. See chapter [A first texture](../basic-3d-"
"rendering/texturing/a-first-texture.md) for more details about the "
"texture creation."
msgstr ""

#: ../../advanced-techniques/headless.md:143
msgid ""
"The `nextTexture` of the main loop is now simply a view of the target "
"texture."
msgstr ""

#: ../../advanced-techniques/headless.md:187
msgid ""
"Depending on your use case you could have **more advanced target texture "
"management**, with for instance multiple textures that you swap so that "
"you can render the next frame while saving the previous one on disc for "
"instance."
msgstr ""

#: ../../advanced-techniques/headless.md:190
msgid ""
"Since we reuse the same view from one frame to another one, **do not "
"release it**!:"
msgstr ""

#: ../../advanced-techniques/headless.md:206
msgid "Saving frames"
msgstr ""

#: ../../advanced-techniques/headless.md:208
msgid "We no longer need to *present* the swap chain:"
msgstr ""

#: ../../advanced-techniques/headless.md:215
msgid ""
"But this means nothing is done with the rendered texture! In order to see"
" it, we can use the `saveImage` function provided in the [Screen capture"
"](screen-capture.md) chapter."
msgstr ""

#: ../../advanced-techniques/headless.md:217
msgid ""
"With the files [save_image.h](../data/save_image.h) and "
"[stb_image_write.h](../data/stb_image_write.h) saved next to your "
"`main.cpp`, **replace the swap chain presentation** with the following:"
msgstr ""

#: ../../advanced-techniques/headless.md:224
msgid "Also include the save_image.h file at the beginning of your main file:"
msgstr ""

#: ../../advanced-techniques/headless.md:231
msgid "Main Loop"
msgstr ""

#: ../../advanced-techniques/headless.md:234
msgid ""
"The main loop consisted in rendering a new frame until the window gets "
"closed:"
msgstr ""

#: ../../advanced-techniques/headless.md:244
msgid ""
"What this becomes totally depends on your use case. For the sake of this "
"example, we will just keep the brackets but actually run its content "
"**only once** then terminate the program:"
msgstr ""

#: ../../advanced-techniques/headless.md:253
msgid "Clean-up"
msgstr ""

#: ../../advanced-techniques/headless.md:256
msgid ""
"If you run the program now, it should already create a `output.png` file "
"(in the `build` directory)! You may finally remove all the unused parts "
"and get rid of GLFW altogether:"
msgstr ""

#: ../../advanced-techniques/headless.md:290
msgid ""
"You may also remove the directories `glfw` and `glfw3webgpu` and remove "
"them from the `CMakeLists.txt`:"
msgstr ""

#: ../../advanced-techniques/index.md:1
msgid "Advanced Techniques"
msgstr ""

#: ../../advanced-techniques/instanced-drawing.md:1
msgid "Instanced Drawing (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/instanced-drawing.md:4
msgid ""
"Drawing the **same geometry multiple times** is very common. It happens "
"when **scattering objects** like rocks or trees on a terrain, when "
"drawing **particle systems**, etc."
msgstr ""

#: ../../advanced-techniques/instanced-drawing.md:6
msgid ""
"Turns out that the GPU is particularly good at drawing such repeated "
"geometry thanks to the mechanism of **instancing**."
msgstr ""

#: ../../advanced-techniques/instanced-drawing.md:9
msgid ""
"It is much **more efficient** than issuing multiple draw calls, not only "
"because it avoids repeating the **overhead of building a draw command**, "
"but also because it enables the GPU to better **manage memory** by "
"streaming the instances through the rendering pipeline simultaneously."
msgstr ""

#: ../../advanced-techniques/instanced-drawing.md:12
msgid ""
"Both the `draw` and `drawIndexed` methods of a render pipeline encoder "
"support instancing (`wgpuRenderPipelineEncoderDraw` and "
"`wgpuRenderPipelineEncoderDrawIndexed`) through their second argument."
msgstr ""

#: ../../advanced-techniques/instanced-drawing.md:18
msgid ""
"But as you will quickly notice if changing this instance count argument, "
"all instances get drawn at the **very same position**!"
msgstr ""

#: ../../advanced-techniques/instanced-drawing.md:20
msgid ""
"A first solution to distinguish instances is in the shader, using the "
"`@builtin(instance_id)` attribute in the vertex shader inputs."
msgstr ""

#: ../../advanced-techniques/instanced-drawing.md:26
msgid "A second solution is to use instance-level vertex attributes. TODO"
msgstr ""

#: ../../advanced-techniques/multi-sampling.md:1
msgid "Multi-Sampling (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/raii.md:1
msgid "RAII"
msgstr ""

#: ../../advanced-techniques/raii.md:4 ../../advanced-techniques/raii.md:230
msgid ""
"*Resulting code:* "
"[`gist`](https://gist.github.com/eliemichel/2e154152f981e3f16827ba4d17d1123a)"
msgstr ""

#: ../../advanced-techniques/raii.md:6
msgid ""
"Ever tired of managing the `foo.release()` to make sure that it matches "
"the `device.createFoo()` and that you don't have dangling resources? This"
" **manual mechanism** is required for a C API, but in C++ we can **wrap**"
" it into a more convenient interface thanks to **destructors**."
msgstr ""

#: ../../advanced-techniques/raii.md:8
msgid ""
"The **programming idiom** presented here is called "
"[RAII](https://en.cppreference.com/w/cpp/language/raii), which stands for"
" *\"Resource Acquisition Is Initialization\"*; it applies to many other "
"non-WebGPU related contexts!"
msgstr ""

#: ../../advanced-techniques/raii.md:10
msgid ""
"The idea is to write a C++ class that we force **by construction** to be "
"such that the underlying resource it represents exists **if and only if**"
" the instance of the class is still alive."
msgstr ""

#: ../../advanced-techniques/raii.md:12
msgid "Motivational examples"
msgstr ""

#: ../../advanced-techniques/raii.md:15
msgid "Function"
msgstr ""

#: ../../advanced-techniques/raii.md:17
msgid ""
"Let us start with some examples, where we assume that we have a class "
"`raii::Buffer` that wraps the `wgpu::Buffer` resource using the RAII "
"idiom."
msgstr ""

#: ../../advanced-techniques/raii.md:31
msgid ""
"Note how there is no need here to call `buffer.release()`: **as soon as "
"the variable goes out of scope** the buffer it wraps is automatically "
"released."
msgstr ""

#: ../../advanced-techniques/raii.md:33
msgid "Class"
msgstr ""

#: ../../advanced-techniques/raii.md:35
msgid ""
"If we need the buffer to live longer, we can typically define it as a "
"class member:"
msgstr ""

#: ../../advanced-techniques/raii.md:58
msgid ""
"This time, the buffer is released whenever the instance of `Foo` is "
"destructed: it automatically calls the destructor of `raii::Buffer`, "
"which releases the buffer resource."
msgstr ""

#: ../../advanced-techniques/raii.md:61
msgid ""
"Since the `raii::Buffer` cannot exist without an underlying buffer, so it"
" must be initialized by the constructor."
msgstr ""

#: ../../advanced-techniques/raii.md:64
msgid "Smart pointers"
msgstr ""

#: ../../advanced-techniques/raii.md:66
msgid ""
"Sometimes we really want to be able to store a \"null\" buffer, so the "
"need to initialize it as soon as we define the RAII instance can be "
"annoying. The typical solution is to use the **smart pointers** provided "
"by the standard library:"
msgstr ""

#: ../../advanced-techniques/raii.md:94
msgid ""
"The smart pointer ensures that the object it points to is destructed when"
" nothing points to it (e.g., when `Foo` gets destructed)."
msgstr ""

#: ../../advanced-techniques/raii.md:97
msgid ""
"The standard type "
"[`std::optional`](https://en.cppreference.com/w/cpp/utility/optional) can"
" also be an interesting option to store a \"maybe buffer\"."
msgstr ""

#: ../../advanced-techniques/raii.md:100
msgid "Implementation"
msgstr ""

#: ../../advanced-techniques/raii.md:103
msgid ""
"So how do we write this `raii::Buffer` wrapper? It looks easy but there "
"are **some caveats to avoid**!"
msgstr ""

#: ../../advanced-techniques/raii.md:131
msgid "This somehow works... until we meet this kind of scheme:"
msgstr ""

#: ../../advanced-techniques/raii.md:143
msgid ""
"At the end of the `if` block, the variable `buffer2` goes out of scope, "
"so its `m_raw` member is released. Except that it was the same `m_raw` as"
" `buffer1` due to the `=` assignment!"
msgstr ""

#: ../../advanced-techniques/raii.md:145
msgid ""
"This snippet will actually systematically crash with a **double free "
"error** because even if you don't use `buffer1` after the `if`, whenever "
"it gets out of scope on its turn its destructor attempt to release a "
"second time `m_raw`."
msgstr ""

#: ../../advanced-techniques/raii.md:147
msgid "Rule of three"
msgstr ""

#: ../../advanced-techniques/raii.md:149
msgid ""
"There is a general rule of thumb in C++ that accurately applies in our "
"case, namely the [Rule of "
"three](https://en.cppreference.com/w/cpp/language/rule_of_three). It says"
" in short:"
msgstr ""

#: ../../advanced-techniques/raii.md:151
msgid ""
"If a class needs either a user-defined **destructor** (`~Foo()`), a user-"
"defined **copy assignment** operator (`operator=(const Foo& other)` or a "
"user-defined **copy constructor** (`Foo(const Foo& other)`), then it very"
" likely need **the three of them**."
msgstr ""

#: ../../advanced-techniques/raii.md:153
msgid ""
"In our case we obviously need a custom destructor, to release the "
"resource, so the rule tells us that we should also manually define **how "
"to copy RAII buffers**."
msgstr ""

#: ../../advanced-techniques/raii.md:172
msgid "How do we implement these copy operations? We have **three options**:"
msgstr ""

#: ../../advanced-techniques/raii.md:174
msgid ""
"**Option A**: We create a new buffer and copy the content of the previous"
" one."
msgstr ""

#: ../../advanced-techniques/raii.md:175
msgid "**Option B**: We deactivate the possibility to copy buffers."
msgstr ""

#: ../../advanced-techniques/raii.md:176
msgid "**Option C**: We count references."
msgstr ""

#: ../../advanced-techniques/raii.md:178
msgid ""
"The problem of Option A is that it turns a seemingly innocent line of "
"code like `buffer2 = buffer1` into a time and memory consuming operation."
" And it requires the buffer object to hold a reference to the `Device` "
"object that must be used to create the new buffer."
msgstr ""

#: ../../advanced-techniques/raii.md:180
msgid ""
"Option B make things clearer to the user of the API by forcing the use of"
" a more explicit method (e.g., `buffer.copyFrom(device, other)`). In this"
" case we simply delete the copy operator/constructor:"
msgstr ""

#: ../../advanced-techniques/raii.md:188
msgid ""
"Option C consists in using a counter to keep track of how many different "
"RAII instances use the same `m_raw`, so that we release it only when no "
"body else is using it."
msgstr ""

#: ../../advanced-techniques/raii.md:190
msgid ""
"One possibility for this is to implement Option B but then use "
"`std::shared_pointer<raii::Buffer>`, because a shared pointer is "
"precisely a (smart) pointer with a reference counter."
msgstr ""

#: ../../advanced-techniques/raii.md:192
msgid ""
"Another possibility is to use the `buffer.reference()` (or "
"`wgpuBufferReference`) procedure to increase an internal counter on the "
"WebGPU backend side."
msgstr ""

#: ../../advanced-techniques/raii.md:194
msgid "Rule of five"
msgstr ""

#: ../../advanced-techniques/raii.md:196
msgid ""
"Defining custom copy operator/constructor deactivates the automatic "
"creation of **move** operator/constructor. A variant of the Rule of "
"three, called the **Rule of five**, states that should also take care of "
"these move semantics."
msgstr ""

#: ../../advanced-techniques/raii.md:198
msgid ""
"These defines what happens when we do, among others, `buffer2 = "
"std::move(buffer1)`, which means that `buffer1` will never be used again."
" It also enables one to create a function that returns a `raii::Buffer` "
"without performing any copy."
msgstr ""

#: ../../advanced-techniques/raii.md:200
msgid ""
"In such a case, we can simply move the value of `m_raw` from `buffer1` to"
" `buffer2`, removing it from `buffer1` so that it can no longer release "
"it."
msgstr ""

#: ../../advanced-techniques/raii.md:222
msgid ""
"We created a way to have a RAII object that points to no underlying "
"resource, but this is done in a way that follows the C++ lifetime "
"semantics so the compiler can be aware of it."
msgstr ""

#: ../../advanced-techniques/raii.md:228
msgid ""
"We have seen how to create a RAII wrapper around a WebGPU buffer, and "
"from this one implementing other classes is straightforward (you could "
"even automate it). And keep this design pattern in mind even for other "
"projects, as it is a very common and powerful idiom!"
msgstr ""

#: ../../advanced-techniques/raytracing.md:1
msgid "Raytracing (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/render-bundles.md:1
msgid "Render Bundles (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/render-bundles.md:4
msgid ""
"A [Render Bundle](https://www.w3.org/TR/webgpu/#gpurenderbundle) is a way"
" to record a series of render passes so that they can be replayed "
"together in a single call."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:1
msgid "Scene tree (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:5
#: ../../advanced-techniques/scene-tree.md:235
msgid ""
"*Resulting code:* [`step100-gltf`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step100-gltf)"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:9
#: ../../advanced-techniques/scene-tree.md:239
msgid ""
"*Resulting code:* [`step100-gltf-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step100-gltf-vanilla)"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:12
msgid "Multiple objects"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:15
msgid ""
"Before moving on to a whole scene tree, let us start organizing our code "
"to draw **more than a single mesh**."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:17
msgid "TODO"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:19
msgid "Loading GLTF"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:22
msgid ""
"A very common format for representing 3D scenes made of a hierarchy of "
"multiple (potentially animated) objects is "
"[GLTF](https://github.com/KhronosGroup/glTF). In this chapter, we see how"
" to load a GLTF file into our example application."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:24
msgid ""
"We use the popular [TinyGLTF](https://github.com/syoyo/tinygltf) library:"
" it is header-only (thus easy to integrate), well maintained, and relies "
"on dependencies that we are already using for texture loading: "
"`stb_image.h`."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:27
msgid "This chapter is based on `step100`."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:30
msgid ""
"Download "
"[`tiny_gltf.h`](https://github.com/syoyo/tinygltf/blob/release/tiny_gltf.h),"
" [`json.hpp`](https://github.com/syoyo/tinygltf/blob/release/json.hpp) "
"and "
"[`stb_image_write.h`](https://github.com/syoyo/tinygltf/blob/release/stb_image_write.h)"
" (you should already have `stb_image.h`)."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:32
msgid ""
"Similarly to all the tiny libraries that we have been using, add the "
"following to `implementations.cpp` (or any other cpp file as long as it "
"is **only in one** of them)."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:47
msgid ""
"In order to get familiarized with this new loading library, let us do as "
"if it was only loading a single mesh, like our OBJ loading function. "
"Create a new static method in the `ResourceManager` class:"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:57
msgid "We start by simply checking that we load the file correctly:"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:90
msgid "As an example, we will use the typical Sci-Fi Helmet:"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:94
msgid ""
"Download [DamagedHelmet.glb](https://github.com/KhronosGroup/glTF-Sample-"
"Models/raw/master/2.0/DamagedHelmet/glTF-Binary/DamagedHelmet.glb) into "
"your resource directory and try to load it in the application:"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:105
msgid ""
"GLTF files can have either the `.gltf` or `.glb` extension. The latter "
"has a 'b' for **binary** and is more compact, but less human-readable. It"
" also embeds all its dependencies, whereas a .gltf"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:108
msgid "Uploading Scene Data"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:111
msgid ""
"Now that we have loaded the GLTF data in its native representation on "
"CPU, we must organize it to fit our render pipeline, and upload all we "
"need to the GPU."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:113
msgid ""
"In order to **avoid unneeded copies** and data processing, we try to let "
"the GLTF scene drive our rendering process. There are however a few "
"points that are driven by the need of our shader:"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:115
msgid "The list of **input vertex attributes** that we support and expect."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:117
msgid "Initializing the GPU counterpart of the CPU model data consists in:"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:119
msgid ""
"Uploading resources (buffers and images), assuming that they are all "
"needed (otherwise we can eventually add a step to clean up the GLTF "
"data). Create mipmaps for textures (called \"images\" in GLTF "
"terminology)."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:120
msgid "Create samplers (on to one mapping of the concept of mappings in GLTF)"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:121
msgid "Create a Material bind group for each material"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:122
msgid "Create one Node bind group per mesh node"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:123
msgid "Store vertex buffer indices for all mesh primitives"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:125
msgid "WIP Outline:"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:126
msgid ""
"Refactor the geometry loading so that we have a Scene and GpuScene "
"object, used for both loading and drawing."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:127
msgid "Switch this to GLFW."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:130
msgid ""
"The existence of a vertex attribute binding must depend on what the "
"shader uses, but the layout itself depends on the GLTF data."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:133
msgid "Debug Renderer"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:135
msgid ""
"We start with a simple debug renderer that draws one frame per node in "
"the scene tree."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:158
msgid ""
"Let us start by what we want to draw. As we said, we want one frame per "
"node in the scene tree:"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:178
msgid ""
"We do not use instancing here on purpose. It is true that for drawing the"
" very same geometry at each node like we do here it is a waste not to use"
" instancing, but we will use this simplified example as a base for "
"drawing a different mesh at each node. I will show afterwards how to "
"switch to instancing in this debug renderer."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:181
msgid ""
"Now that we know what we are looking for, let us define our required "
"attributes and initialize them in the `create` method:"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:197
msgid ""
"Note that we keep a reference to the device, in order to use it in "
"various methods. It is also used as a mean to tell that the renderer has "
"been initialized when it is not null."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:215
msgid ""
"We then create init/terminate methods for the various elements of our "
"renderer:"
msgstr ""

#: ../../advanced-techniques/screen-capture.md:1
msgid "Screen capture (ðŸš§WIP)"
msgstr ""

#: ../../advanced-techniques/screen-capture.md:4
msgid "Render screen to file"
msgstr ""

#: ../../advanced-techniques/screen-capture.md:7
msgid ""
"Download [save_image.h](../data/save_image.h) and "
"[stb_image_write.h](../data/stb_image_write.h) next to your `main.cpp`."
msgstr ""

#: ../../advanced-techniques/screen-capture.md:34
msgid "After introducing the `Application` class:"
msgstr ""

#: ../../advanced-techniques/shadow-maps.md:1
msgid "Shadow maps (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/shadow-maps.md:4
msgid "Basic shadow mapping:"
msgstr ""

#: ../../advanced-techniques/shadow-maps.md:5
msgid "Render a depth-only view from the point of view of your light"
msgstr ""

#: ../../advanced-techniques/shadow-maps.md:6
msgid "Render your scene from the camera as usual"
msgstr ""

#: ../../advanced-techniques/shadow-maps.md:7
msgid ""
"In the fragment shader of this draw call, compute the vector going from "
"the light to your fragment, and use it for 2 things: a. Given its "
"direction, determine which pixel it corresponds to in the depth-only view"
" from step 1, fetch the depth for this pixel b. Compare that depth to the"
" length of the fragment-light vector."
msgstr ""

#: ../../advanced-techniques/shadow-maps.md:11
msgid ""
"If the saved depth is smaller, this means there is an obstacle between "
"your fragment and the light, so the fragment is in a shadow. If the saved"
" depth roughly equals the length, fragment is lit. If it is larger, "
"there's sth wrong (or just aliasing going on)"
msgstr ""

#: ../../advanced-techniques/shadow-maps.md:14
msgid ""
"It is easy to go wrong in **3.a.** with the math, I'd advise to double "
"check. Also for **3.b.** be aware that a depth buffer does not directly "
"store a length, you must linearize its value to be able to compare it "
"with the length of a vector."
msgstr ""

#: ../../advanced-techniques/tesselation.md:1
msgid "Tesselation (ðŸ›‘TODO)"
msgstr ""

