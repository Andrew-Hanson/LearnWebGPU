# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022-2023, Ã‰lie Michel and contributors
# This file is distributed under the same license as the Learn WebGPU for
# C++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Learn WebGPU for C++ \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-25 09:12+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: fr\n"
"Language-Team: fr <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../../getting-started/cpp-idioms.md:1
msgid "C++ wrapper"
msgstr ""

#: ../../getting-started/cpp-idioms.md:4
#: ../../getting-started/cpp-idioms.md:176
msgid ""
"*Resulting code:* [`step025`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step025)"
msgstr ""

#: ../../getting-started/cpp-idioms.md:6
msgid ""
"So far we have used the raw WebGPU API, which is a C API, and this "
"prevented us from using some nice productive features of C++. This "
"chapter first gives imaginary examples of how this could be improved, "
"before linking to a little library that implement all this little "
"features."
msgstr ""

#: ../../getting-started/cpp-idioms.md:9
msgid ""
"All the changes presented here only affect the coding time, but our "
"shallow C++ wrapper leads to the very same runtime binaries."
msgstr ""

#: ../../getting-started/cpp-idioms.md:13
msgid ""
"This chapter is not as up to date as [the readme of "
"WebGPU-C++](https://github.com/eliemichel/WebGPU-Cpp). I recommend you "
"read that instead for now."
msgstr ""

#: ../../getting-started/cpp-idioms.md:16
msgid "Default descriptor values"
msgstr ""

#: ../../getting-started/cpp-idioms.md:19
msgid ""
"Sometimes we just need to build a descriptor by default. More generally, "
"we rarely need to have all the fields of the descriptor deviate from the "
"default, so we could benefit from the possibility to have a default "
"constructor for descriptors."
msgstr ""

#: ../../getting-started/cpp-idioms.md:21
msgid "Namespace"
msgstr ""

#: ../../getting-started/cpp-idioms.md:24
msgid ""
"The C interface could not make use of namespaces, since they only exist "
"in C++, so you may have noticed that every single function starts with "
"`wgpu` and every single structure starts with `WGPU`. A more C++ "
"idiomatic way of doing this is to enclose all these functions into a "
"namespace."
msgstr ""

#: ../../getting-started/cpp-idioms.md:32
msgid "becomes with namespaces:"
msgstr ""

#: ../../getting-started/cpp-idioms.md:40
msgid ""
"And of course you can start your source file with `using namespace wgpu;`"
" to avoid spelling out `wgpu::` everywhere. Coupled with default "
"descriptor, this leads to simply:"
msgstr ""

#: ../../getting-started/cpp-idioms.md:47
msgid "Objects"
msgstr ""

#: ../../getting-started/cpp-idioms.md:50
msgid ""
"Beyond namespace, most functions are also prefixed by the name of their "
"first argument, e.g.:"
msgstr ""

#: ../../getting-started/cpp-idioms.md:61
msgid ""
"These functions are conceptually *methods* of the object constituted by "
"their first argument, so in the wrapper they are exposed as such:"
msgstr ""

#: ../../getting-started/cpp-idioms.md:83
msgid ""
"The `const` qualifier is specified for some methods. This is extra "
"information provided by the wrapper to reduce the potential programming "
"mistakes."
msgstr ""

#: ../../getting-started/cpp-idioms.md:86
msgid "Capturing closures"
msgstr ""

#: ../../getting-started/cpp-idioms.md:89
msgid ""
"Many asynchronous operations use callbacks. In order to provide some "
"context to the callback's body, there is always a `void *userdata` "
"argument passed around. This can be alleviated in C++ by using capturing "
"closures."
msgstr ""

#: ../../getting-started/cpp-idioms.md:92
msgid ""
"This only alleviates the notations, but technically mechanism very "
"similar to the user data pointer is automatically implemented when "
"creating a capturing lambda."
msgstr ""

#: ../../getting-started/cpp-idioms.md:111
msgid "becomes"
msgstr ""

#: ../../getting-started/cpp-idioms.md:123
msgid "Scoped enumerations"
msgstr ""

#: ../../getting-started/cpp-idioms.md:126
msgid ""
"Because enums are *unscoped* by default, the WebGPU API is forced to "
"prefix all values that an enum can take with the name of the enum, "
"leading to quite long names:"
msgstr ""

#: ../../getting-started/cpp-idioms.md:138
msgid ""
"It is possible in C++ to define *scoped* enums, which are strongly typed "
"and can only be accessed through the name, for instance this scoped enum:"
msgstr ""

#: ../../getting-started/cpp-idioms.md:150
msgid "This can be used as follows:"
msgstr ""

#: ../../getting-started/cpp-idioms.md:157
msgid ""
"The actual implementation use a little trickery so that enum names are "
"scoped, but implicitly converted to and from the original WebGPU enum "
"values."
msgstr ""

#: ../../getting-started/cpp-idioms.md:160
msgid "Library"
msgstr ""

#: ../../getting-started/cpp-idioms.md:163
msgid ""
"The library providing these C++ idioms is "
"[`webgpu.hpp`](../data/webgpu.hpp). It is made of a single header file, "
"which you just have to copy in your source tree. Exactly one of your "
"source files must define `WEBGPU_CPP_IMPLEMENTATION` before `#include "
"\"webgpu.hpp\"`:"
msgstr ""

#: ../../getting-started/cpp-idioms.md:171
msgid "This header is actually included in the WebGPU zip I provided you earlier."
msgstr ""

#: ../../getting-started/cpp-idioms.md:174
msgid ""
"More information can be found in [the webgpu-cpp "
"repository](https://github.com/eliemichel/WebGPU-Cpp)."
msgstr ""

#: ../../getting-started/first-color.md:1
msgid "First Color"
msgstr ""

#: ../../getting-started/first-color.md:13
#: ../../getting-started/first-color.md:286
msgid ""
"*Resulting code:* [`step020`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step020)"
msgstr ""

#: ../../getting-started/first-color.md:15
msgid ""
"The goal of this chapter is to **draw a solid color** all over our "
"window. This will be the occasion to introduce 3 new concepts of WebGPU:"
msgstr ""

#: ../../getting-started/first-color.md:17
msgid "Swap Chains"
msgstr ""

#: ../../getting-started/first-color.md:18
msgid "Texture Views"
msgstr ""

#: ../../getting-started/first-color.md:19
msgid "Render Passes"
msgstr ""

#: ../../getting-started/first-color.md:21
msgid "Swap Chain"
msgstr ""

#: ../../getting-started/first-color.md:24
msgid "Drawing process"
msgstr ""

#: ../../getting-started/first-color.md:26
msgid ""
"To understand the notion of **Swap Chain**, we need to know a little more"
" about how the window's surface is drawn."
msgstr ""

#: ../../getting-started/first-color.md:28
msgid ""
"First, the render pipeline **does not draw directly on the texture that "
"is currently displayed**, otherwise we would see pixels change all the "
"time. A typical pipeline draws to an off-screen texture, which replaces "
"the currently displayed one only once it is complete. We then say that "
"the texture is **presented** to the surface."
msgstr ""

#: ../../getting-started/first-color.md:30
msgid ""
"Second, drawing takes a **different time** than the frame rate required "
"by your application, so the GPU may have to wait until the next frame is "
"needed. There might be more than one off-screen texture waiting in the "
"queue to be presented, so that fluctuations in the render time get "
"amortized."
msgstr ""

#: ../../getting-started/first-color.md:32
msgid ""
"Last, **these off-screen textures are reused** as much as possible. As "
"soon as a new texture is presented, the previous one can be reused as a "
"target for the next frame. This whole texture swapping mechanism is "
"implemented by the **Swap Chain** object."
msgstr ""

#: ../../getting-started/first-color.md:35
msgid ""
"Remember that the GPU process runs at its own pace and that our CPU-"
"issued commands are only asynchronously executed. Implementing the swap "
"chain process manually would hence require a lot of boilerplate, so we "
"are glad it is provided by the API!"
msgstr ""

#: ../../getting-started/first-color.md:42
msgid ""
"*Left: The render process draws on an off-screen texture. Middle: "
"Rendered textures wait in a queue. Right: At a regular frame rate, "
"rendered textures are presented to the window's surface.*"
msgstr ""

#: ../../getting-started/first-color.md:44
msgid "Creation"
msgstr ""

#: ../../getting-started/first-color.md:46
msgid ""
"As always, we pass swap chain creation option through a descriptor. A "
"first obvious option is the size of all the textures that are "
"manipulated:"
msgstr ""

#: ../../getting-started/first-color.md:56
msgid ""
"As you can guess, we will have to take care of creating a new swap chain "
"**when the window is resized**. In the meantime, do not try to resize it."
" You may add `glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);` before "
"creating the window to instruct GLFW to disable resizing."
msgstr ""

#: ../../getting-started/first-color.md:59
msgid ""
"For the swap chain to **allocate textures**, we also need to specify "
"their **format**. The format is a combination of a number of channels (a "
"subset of red, green, blue, alpha), a size per channel (8, 16 or 32 bits)"
" and a channel type (float, integer, signed or not), a compression "
"scheme, a normalization mode, etc."
msgstr ""

#: ../../getting-started/first-color.md:61
msgid ""
"All available combinations are listed in the `WGPUTextureFormat` enum, "
"but since our swap chain targets an existing surface, we can just use "
"whichever format the surface uses:"
msgstr ""

#: ../../getting-started/first-color.md:72
#: ../../getting-started/the-device.md:222
msgid "Dawn"
msgstr ""

#: ../../getting-started/first-color.md:73
msgid ""
"When using the Dawn implementation of WebGPU, "
"`wgpuSurfaceGetPreferredFormat` is not implemented yet. Actually, the "
"only texture format it supports is `WGPUTextureFormat_BGRA8Unorm`."
msgstr ""

#: ../../getting-started/first-color.md:86
msgid ""
"Textures are allocated for a **specific usage**, that dictates the way "
"the GPU organizes its memory. In our case, we use the swap chain textures"
" as targets for a *Render Pass* so it needs to be created with the "
"`RenderAttachment` usage flag:"
msgstr ""

#: ../../getting-started/first-color.md:92
msgid ""
"Finally, we can tell which texture from the waiting queue must be "
"presented at each frame. Possible values are:"
msgstr ""

#: ../../getting-started/first-color.md:94
msgid ""
"`Immediate`: No off-screen texture is used, the render process directly "
"draws on the surface, which might lead to artifacts (called *tearing*) "
"but has zero latency."
msgstr ""

#: ../../getting-started/first-color.md:95
msgid ""
"`Mailbox`: There is only one slot in the queue, and when a new frame is "
"rendered, it replaces the one currently waiting (which is discarded "
"without ever being presented)."
msgstr ""

#: ../../getting-started/first-color.md:96
msgid ""
"`Fifo`: Stands for \"first in, first out\", meaning that the presented "
"texture is always the oldest one, like a regular queue. No rendered "
"texture is wasted."
msgstr ""

#: ../../getting-started/first-color.md:99
msgid ""
"The `Force32` enum values that you can find when reading the source code "
"of `webgpu.h` is not a \"legal\" value, it is just here to force the "
"underlying enum type to be a 32 bit integer."
msgstr ""

#: ../../getting-started/first-color.md:102
msgid "In our case, we use `Fifo`, as illustrated in the video above."
msgstr ""

#: ../../getting-started/first-color.md:108
msgid "We may now create the swap chain:"
msgstr ""

#: ../../getting-started/first-color.md:120
msgid "And of course at the end of the program we destroy it:"
msgstr ""

#: ../../getting-started/first-color.md:127
msgid ""
"The Swap Chain is something that is not exposed in the JavaScript version"
" of the API. Like the notion of *surface* that we have met already, by "
"the way. The web browser takes care of it and does not offer any option."
msgstr ""

#: ../../getting-started/first-color.md:130
msgid "Troubleshooting"
msgstr ""

#: ../../getting-started/first-color.md:131
msgid ""
"If you get the error `Uncaptured device error: type 3 "
"(Device(OutOfMemory))` when calling `wgpuDeviceCreateSwapChain`, check "
"that you specified the `GLFW_NO_API` value to glfw when creating the "
"window."
msgstr ""

#: ../../getting-started/first-color.md:134
msgid "Texture View"
msgstr ""

#: ../../getting-started/first-color.md:137
msgid ""
"Let's move on to the **main loop** and see how to use the swap chain. As "
"explained above, the swap chain provides us with the texture where to "
"draw the next frame. It is as simple as this:"
msgstr ""

#: ../../getting-started/first-color.md:154
msgid ""
"Note that this returns a **Texture View**. This gives a restricted access"
" to the actual texture object allocated by the swap chain, so that "
"internally the swap chain can use whatever organization it wants while "
"exposing a view that has the dimensions and format that we expect."
msgstr ""

#: ../../getting-started/first-color.md:156
msgid ""
"Getting the texture view **may fail**, in particular if the window has "
"been resized and thus the target surface changed, so don't forget to "
"check that it is not null:"
msgstr ""

#: ../../getting-started/first-color.md:165
msgid ""
"The texture view is **used only for a single frame**, after which it is "
"our responsibility to destroy it:"
msgstr ""

#: ../../getting-started/first-color.md:171
msgid ""
"At the end of the main loop, once the texture is filled in and the view "
"released, we can tell the swap chain to present the next texture (which "
"depends on the `presentMode` of the swap chain):"
msgstr ""

#: ../../getting-started/first-color.md:177
msgid "Render Pass"
msgstr ""

#: ../../getting-started/first-color.md:180
msgid "Render pass encoder"
msgstr ""

#: ../../getting-started/first-color.md:182
msgid ""
"We now hold the texture where to draw to display something in our window."
" Like any GPU-side operation, we trigger drawing operations from the "
"command queue, using a command encoder as described in [the previous "
"chapter](the-command-queue.md)."
msgstr ""

#: ../../getting-started/first-color.md:184
msgid ""
"Build a `WGPUCommandEncoder` called `encoder`, then submit it to the "
"queue. In between we will add a command that clears the screen with a "
"uniform color."
msgstr ""

#: ../../getting-started/first-color.md:192
msgid ""
"If you look in `webgpu.h` at the methods of the encoder (the procedures "
"starting with `wgpuCommandEncoder`), most of them are related to copying "
"buffers and textures around. Except **two special ones**: "
"`wgpuCommandEncoderBeginComputePass` and "
"`wgpuCommandEncoderBeginRenderPass`. These return specialized encoder "
"objects, namely `WGPUComputePassEncoder` and `WGPURenderPassEncoder`, "
"that give access to commands dedicated to respectively computing and 3D "
"rendering."
msgstr ""

#: ../../getting-started/first-color.md:194
msgid "In our case, we use a render pass:"
msgstr ""

#: ../../getting-started/first-color.md:203
msgid ""
"Note that we directly end the pass without issuing any other command. "
"This is because the render pass has a built-in mechanism for clearing the"
" screen when it begins, which we'll set up through the descriptor."
msgstr ""

#: ../../getting-started/first-color.md:205
msgid "Color attachment"
msgstr ""

#: ../../getting-started/first-color.md:207
msgid ""
"A render pass leverages the 3D rendering circuits of the GPU to draw "
"content into one or multiple textures. So one important thing to set up "
"is to tell **which textures are the target** of this process. These are "
"the **attachments** of the render pass."
msgstr ""

#: ../../getting-started/first-color.md:209
msgid ""
"The number of attachment is variable, so the descriptor gets it through "
"two fields: the number `colorAttachmentCount` of attachments and the "
"address `colorAttachments` of the color attachment array. Since we only "
"use one, the address of the array is just the address of a single "
"`WGPURenderPassColorAttachment` variable."
msgstr ""

#: ../../getting-started/first-color.md:219
msgid ""
"The first important setting of the attachment is the texture view it must"
" draw in. In our case, the view returned by the swap chain because we "
"directly want to draw on screen, but in advanced pipelines it is very "
"common to draw on intermediate textures, which are then fed to e.g., "
"post-process passes."
msgstr ""

#: ../../getting-started/first-color.md:225
msgid ""
"There is a second target texture view called `resolveTarget`, but it is "
"not relevant here because we do not use *multi-sampling* (more on this "
"later)."
msgstr ""

#: ../../getting-started/first-color.md:231
msgid ""
"The `loadOp` setting indicates the load operation to perform on view "
"prior to executing the render pass. It can be either read from the view "
"or set to a default uniform color, namely the clear value. When it does "
"not matter, use `WGPULoadOp_Clear` as it is likely more efficient."
msgstr ""

#: ../../getting-started/first-color.md:233
msgid ""
"The `storeOp` indicates the operation to perform on view after executing "
"the render pass. It can be either stored or discarded (which only makes "
"sense if the render pass has side-effects)."
msgstr ""

#: ../../getting-started/first-color.md:235
msgid ""
"And the `clearValue` is the value to clear the screen with, put anything "
"you want in here! The 4 values are the red, green, blue and alpha "
"channels, on a scale from 0.0 to 1.0."
msgstr ""

#: ../../getting-started/first-color.md:243
msgid "Misc"
msgstr ""

#: ../../getting-started/first-color.md:245
msgid ""
"There is also one special type of attachment, namely the *depth* and "
"*stencil* attachment (it is a single attachment potentially containing "
"two channels). We'll come back on this later on, for now we do not use it"
" so we set it to null:"
msgstr ""

#: ../../getting-started/first-color.md:251
msgid ""
"When measuring the performance of a render pass, it is not possible to "
"use CPU-side timing functions, since the commands are not executed "
"synchronously. Instead, the render pass can receive a set of timestamp "
"queries. We do not use it in this example."
msgstr ""

#: ../../getting-started/first-color.md:258
msgid ""
"Lastly, we set `nextInChain` to a null pointer (remember this pointer is "
"an extension mechanism that the standard WebGPU API does not use)."
msgstr ""

#: ../../getting-started/first-color.md:264
#: ../../getting-started/hello-webgpu.md:263
#: ../../getting-started/the-adapter.md:374
#: ../../getting-started/the-command-queue.md:183
msgid "Conclusion"
msgstr ""

#: ../../getting-started/first-color.md:267
msgid ""
"At this stage you should be able to get a colored window. This seems "
"simple, but it made us meet a lot of important concepts."
msgstr ""

#: ../../getting-started/first-color.md:269
msgid ""
"Instead of directly drawing to the window's surface, we draw to an off-"
"screen texture and the **swap chain** is responsible for managing the "
"texture turn over."
msgstr ""

#: ../../getting-started/first-color.md:270
msgid ""
"The 3D rendering pipeline of the GPU is leveraged through the **render "
"pass**, which is a special scope of commands accessible through the "
"command encoder."
msgstr ""

#: ../../getting-started/first-color.md:271
msgid ""
"The render pass draws to one or multiple **attachments**, which are "
"texture views."
msgstr ""

#: ../../getting-started/first-color.md:277
msgid "Our first color!"
msgstr ""

#: ../../getting-started/first-color.md:281
msgid ""
"When using Dawn, the displayed color is potentially different because the"
" surface color format uses another color space. More on this [later"
"](../basic-3d-rendering/input-geometry/loading-from-file.md)!"
msgstr ""

#: ../../getting-started/first-color.md:284
msgid ""
"We are now ready with the basic WebGPU setup, and can dive more deeply in"
" the 3D rendering pipeline."
msgstr ""

#: ../../getting-started/hello-webgpu.md:1
msgid "Hello WebGPU"
msgstr ""

#: ../../getting-started/hello-webgpu.md:10
#: ../../getting-started/hello-webgpu.md:268
msgid ""
"*Resulting code:* [`step005`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step005)"
msgstr ""

#: ../../getting-started/hello-webgpu.md:12
msgid ""
"For your C++ code, WebGPU is nothing more than a single header file "
"listing all the available procedures and data structures: "
"[`webgpu.h`](https://github.com/webgpu-native/webgpu-"
"headers/blob/main/webgpu.h). When building the program though, your "
"compiler must know in the end (at the final *linking* step) where to find"
" the actual implementation of these functions."
msgstr ""

#: ../../getting-started/hello-webgpu.md:16
msgid ""
"A *Render Hardware Interface* (RHI) like WebGPU is not directly provided "
"by the drivers: we need to link to a library that implements the API on "
"top of the low-level one that the system supports."
msgstr ""

#: ../../getting-started/hello-webgpu.md:19
msgid "Installing WebGPU"
msgstr ""

#: ../../getting-started/hello-webgpu.md:22
msgid "There exists mostly two implementations of the WebGPU native header:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:24
msgid ""
"[wgpu-native](https://github.com/gfx-rs/wgpu-native), exposing a native "
"interface to the [`wgpu`](https://github.com/gfx-rs/wgpu) Rust library "
"developed for Firefox."
msgstr ""

#: ../../getting-started/hello-webgpu.md:25
msgid "Google's [Dawn](https://dawn.googlesource.com/dawn), developed for Chrome."
msgstr ""

#: ../../getting-started/hello-webgpu.md:29
msgid ""
"There are (at least) two implementations of WebGPU, developed for the two"
" main web engines."
msgstr ""

#: ../../getting-started/hello-webgpu.md:32
msgid ""
"These two implementations still have **some discrepancies**, but they "
"will disappear as the WebGPU specification gets stable. I try to write "
"this guide such that it **works for both** of them."
msgstr ""

#: ../../getting-started/hello-webgpu.md:34
msgid ""
"To make the integration of either of these in a CMake project as easy as "
"with GLFW and without too many extra dependencies, I share a [WebGPU-"
"distribution](https://github.com/eliemichel/WebGPU-distribution) "
"repository that lets you chose one of the following options:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:36
msgid "Option A: The lightness of wgpu-native"
msgstr ""

#: ../../getting-started/hello-webgpu.md:38
msgid ""
"Since `wgpu-native` is written in rust, we cannot easily build it from "
"scratch so the distribution includes pre-compiled libraries:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:41
msgid ""
"**WIP:** Use the \"for any platform\" link rather than the platform-"
"specific ones, I haven't automated their generation yet so they are "
"usually behind the main one."
msgstr ""

#: ../../getting-started/hello-webgpu.md:44
msgid ""
"[wgpu-native for any platform](https://github.com/eliemichel/WebGPU-"
"distribution/archive/refs/heads/wgpu.zip) (a bit heavier as it's a merge "
"of all the above basically)"
msgstr ""

#: ../../getting-started/hello-webgpu.md:45
msgid "[wgpu-native for Linux](#)"
msgstr ""

#: ../../getting-started/hello-webgpu.md:46
msgid "[wgpu-native for Windows](#)"
msgstr ""

#: ../../getting-started/hello-webgpu.md:47
msgid "[wgpu-native for MacOS](#)"
msgstr ""

#: ../../getting-started/hello-webgpu.md:50
msgid ""
"The pre-compiled binaries are provided by the `wgpu-native` project "
"itself so you can likely trust them. The only thing my distribution adds "
"is a `CMakeLists.txt` that makes it easy to integrate."
msgstr ""

#: ../../getting-started/hello-webgpu.md:53
#: ../../getting-started/hello-webgpu.md:70
#: ../../getting-started/hello-webgpu.md:131
msgid "**Pros**"
msgstr ""

#: ../../getting-started/hello-webgpu.md:54
msgid "This is the most lightweight to build with."
msgstr ""

#: ../../getting-started/hello-webgpu.md:56
#: ../../getting-started/hello-webgpu.md:75
#: ../../getting-started/hello-webgpu.md:134
msgid "**Cons**"
msgstr ""

#: ../../getting-started/hello-webgpu.md:57
msgid "You do not build from source."
msgstr ""

#: ../../getting-started/hello-webgpu.md:58
msgid "`wgpu-native` does not give as informative debug information as Dawn."
msgstr ""

#: ../../getting-started/hello-webgpu.md:60
msgid "Option B: The comfort of Dawn"
msgstr ""

#: ../../getting-started/hello-webgpu.md:62
msgid ""
"Dawn gives much better error messages, and since it is written in C++ we "
"can build it from source and thus inspect more deeply the stack trace in "
"case of crash:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:64
msgid ""
"[Dawn for any platform](https://github.com/eliemichel/WebGPU-"
"distribution/archive/refs/heads/dawn.zip)"
msgstr ""

#: ../../getting-started/hello-webgpu.md:67
msgid ""
"The Dawn-based distribution I provide here fetches the source code of "
"Dawn from its original repository, but in an as shallow as possible way, "
"and pre-sets some options to avoid building parts that we do not use."
msgstr ""

#: ../../getting-started/hello-webgpu.md:72
msgid ""
"Dawn is much more comfortable to develop with, because it gives more "
"detailed error messages"
msgstr ""

#: ../../getting-started/hello-webgpu.md:73
msgid ""
"It is in general ahead of `wgpu-native` regarding the progress of "
"implementation (but `wgpu-native` will catch up eventually)."
msgstr ""

#: ../../getting-started/hello-webgpu.md:76
msgid ""
"Although I reduced the need for extra dependencies, you still need to "
"[install Python](https://www.python.org/) and [git](https://git-"
"scm.com/download)."
msgstr ""

#: ../../getting-started/hello-webgpu.md:77
msgid ""
"The distribution fetches Dawn's source code and its dependencies so the "
"first time you build you need an **Internet connection**."
msgstr ""

#: ../../getting-started/hello-webgpu.md:78
msgid ""
"The initial build takes significantly longer, and occupies more disk "
"space overall."
msgstr ""

#: ../../getting-started/hello-webgpu.md:80
msgid "Integration"
msgstr ""

#: ../../getting-started/hello-webgpu.md:82
msgid "Whichever distribution you choose, the integration is the same:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:84
msgid "Download the zip of your choice."
msgstr ""

#: ../../getting-started/hello-webgpu.md:85
msgid ""
"Unzip it at the root of the project, there should be a `webgpu/` "
"directory containing a `CMakeLists.txt` file and some other (.dll or "
".so)."
msgstr ""

#: ../../getting-started/hello-webgpu.md:86
msgid "Add `add_subdirectory(webgpu)` in your `CMakeLists.txt`."
msgstr ""

#: ../../getting-started/hello-webgpu.md:94
msgid ""
"When using Dawn, make sure to add the `webgpu` directory **after** you "
"add `glfw`, otherwise Dawn provides its own version (which may be fine "
"sometimes, but you don't get to chose the version)."
msgstr ""

#: ../../getting-started/hello-webgpu.md:97
msgid ""
"Add the `webgpu` target as a dependency of our app, after GLFW in the "
"`target_link_libraries` command."
msgstr ""

#: ../../getting-started/hello-webgpu.md:104
msgid ""
"One additional step when using pre-compiled binaries: call the function "
"`target_copy_webgpu_binaries(App)` at the end of `CMakeLists.txt`, this "
"makes sure that the .dll/.so file that your binary depends on at runtime "
"is copied next to it. Whenever you distribute your application, make sure"
" to also distribute this dynamic library file as well."
msgstr ""

#: ../../getting-started/hello-webgpu.md:114
msgid ""
"In the case of Dawn, there is no precompiled binaries to copy but I "
"define the `target_copy_webgpu_binaries` function anyway (it does "
"nothing) so that you can really use the same CMakeLists with both "
"distributions."
msgstr ""

#: ../../getting-started/hello-webgpu.md:117
msgid "Option C: The flexibility of both"
msgstr ""

#: ../../getting-started/hello-webgpu.md:119
msgid ""
"Bonus option that I use in the accompanying code that enables to decide "
"on one distribution or the other upon calling `cmake`:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:127
msgid "This is given by the `main` branch of my distribution repository:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:129
msgid ""
"[WebGPU any distribution](https://github.com/eliemichel/WebGPU-"
"distribution/archive/refs/heads/main.zip)"
msgstr ""

#: ../../getting-started/hello-webgpu.md:132
msgid ""
"You can have two `build` at the same time, one that uses Dawn and one "
"that uses `wgpu-native`"
msgstr ""

#: ../../getting-started/hello-webgpu.md:135
msgid ""
"This is a \"meta-distribution\" that fetches the one you want at "
"configuration time (i.e., when calling `cmake` the first time) so you "
"need an **Internet connection** and **git** at that time."
msgstr ""

#: ../../getting-started/hello-webgpu.md:137
msgid ""
"And of course depending on your choice the pros and cons of *Option A* "
"and *Option B* apply."
msgstr ""

#: ../../getting-started/hello-webgpu.md:139
msgid "Building for the Web"
msgstr ""

#: ../../getting-started/hello-webgpu.md:141
msgid ""
"If you are interested in building your application for the web, you can "
"consult [the dedicated appendix](../appendices/building-for-the-web.md)!"
msgstr ""

#: ../../getting-started/hello-webgpu.md:143
msgid "Testing the installation"
msgstr ""

#: ../../getting-started/hello-webgpu.md:146
msgid ""
"To test the implementation, we simply create the WebGPU **instance**, "
"i.e., the equivalent of the `navigator.gpu` we could get in JavaScript. "
"We then check it and destroy it."
msgstr ""

#: ../../getting-started/hello-webgpu.md:163
msgid "Descriptors and Creation"
msgstr ""

#: ../../getting-started/hello-webgpu.md:165
msgid ""
"The instance is created using the `wgpuCreateInstance` function. Like all"
" WebGPU functions meant to **create** an entity, it takes as argument a "
"**descriptor**, which we can use to specify options regarding how to set "
"up this object."
msgstr ""

#: ../../getting-started/hello-webgpu.md:177
msgid ""
"The descriptor is a kind of way to pack many function arguments together,"
" because some descriptors really have a lot of fields. It can also be "
"used to write utility functions that take care of populating the "
"arguments, to ease the program's architecture."
msgstr ""

#: ../../getting-started/hello-webgpu.md:180
msgid ""
"We meet another WebGPU idiom in the `WGPUInstanceDescriptor` structure: "
"the first field of a descriptor is always a pointer called `nextInChain`."
" This is a generic way for the API to enable custom extensions to be "
"added in the future, or to return multiple entries of data. In a lot of "
"cases, we set it to `nullptr`."
msgstr ""

#: ../../getting-started/hello-webgpu.md:183
msgid "Check"
msgstr ""

#: ../../getting-started/hello-webgpu.md:185
msgid ""
"A WebGPU entity created with a `wgpuCreateSomething` function is "
"technically **just a pointer**. It is a blind handle that identifies the "
"actual object, which lives on the backend side and to which we never need"
" direct access."
msgstr ""

#: ../../getting-started/hello-webgpu.md:187
msgid ""
"To check that an object is valid, we can just compare it with `nullptr`, "
"or use the boolean operator:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:201
msgid ""
"This should display something like `WGPU instance: 000001C0D2637720` at "
"startup."
msgstr ""

#: ../../getting-started/hello-webgpu.md:203
msgid "Destruction and lifetime management"
msgstr ""

#: ../../getting-started/hello-webgpu.md:205
msgid ""
"All the entities that can be **created** using WebGPU entities must "
"eventually be **released**. A procedure that creates an object always "
"looks like `wgpuCreateSomething`, and its equivalent for releasing it is "
"`wgpuSomethingRelease`."
msgstr ""

#: ../../getting-started/hello-webgpu.md:207
msgid ""
"Note that each object internally holds a reference counter, and releasing"
" it only frees related memory if no other part of your code still "
"references it (i.e., the counter falls to 0):"
msgstr ""

#: ../../getting-started/hello-webgpu.md:227
msgid "In particular, we need to release the global WebGPU instance:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:235
msgid ""
"In older versions of `wgpu-native`, the Release and Reference functions "
"did not exist, and a Drop function was used to immediately free an "
"object. See details in [this GitHub issue](https://github.com/webgpu-"
"native/webgpu-headers/issues/9)."
msgstr ""

#: ../../getting-started/hello-webgpu.md:246
msgid "Implementation-specific behavior"
msgstr ""

#: ../../getting-started/hello-webgpu.md:248
msgid ""
"In order to handle the slight differences between implementations, the "
"distributions I provide also define the following preprocessor variables:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:261
msgid ""
"The case of emscripten only occurs when trying to compile our code as a "
"WebAssembly module, which is covered in the [Building for the "
"Web](../appendices/building-for-the-web.md) appendix."
msgstr ""

#: ../../getting-started/hello-webgpu.md:266
msgid ""
"In this chapter we set up WebGPU and learnt that there are **multiple "
"backends** available. We also saw the basic idioms of **object creation "
"and destruction** that will be used all the time in WebGPU API!"
msgstr ""

#: ../../getting-started/index.md:1
msgid "Getting Started"
msgstr ""

#: ../../getting-started/index.md:4
msgid "Contents"
msgstr ""

#: ../../getting-started/opening-a-window.md:1
msgid "Opening a window"
msgstr ""

#: ../../getting-started/opening-a-window.md:10
#: ../../getting-started/opening-a-window.md:131
msgid ""
"*Resulting code:* [`step001`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step001)"
msgstr ""

#: ../../getting-started/opening-a-window.md:12
msgid ""
"Before being able to render anything on screen, we need to ask the "
"Operating System to hand us some place where to draw things, something "
"commonly known as a **window**."
msgstr ""

#: ../../getting-started/opening-a-window.md:14
msgid ""
"Unfortunately, the process to open a window depends a lot on the OS, so "
"we use a little library called [GLFW](https://www.glfw.org/) which "
"unifies the different window management APIs and enables our code to be "
"**agnostic** in the OS."
msgstr ""

#: ../../getting-started/opening-a-window.md:17
msgid ""
"I try to use as little libraries as I can, but this one is required to "
"make our code cross-platform, which feels even more important to me than "
"writing code from scratch. It is furthermore a very common choice and "
"quite minimal in its design."
msgstr ""

#: ../../getting-started/opening-a-window.md:20
msgid "Headless mode"
msgstr ""

#: ../../getting-started/opening-a-window.md:21
msgid ""
"WebGPU **does not require a window** to work actually, it may also run "
"headless. Since this is not a use case as common as drawing in a window, "
"I leave the details of this option to [a dedicated chapter](../advanced-"
"techniques/headless.md) of the advanced section."
msgstr ""

#: ../../getting-started/opening-a-window.md:24
msgid "Installation of GLFW"
msgstr ""

#: ../../getting-started/opening-a-window.md:27
msgid ""
"We do **not need to install** it, we just need to add the code of GLFW to"
" our project directory. Download the file [glfw.zip](../data/glfw.zip) "
"(621 KB) and **unzip** it in your project. This is a stripped down "
"version of the official release where I removed documentation, examples "
"and tests so that it is more **lightweight**."
msgstr ""

#: ../../getting-started/opening-a-window.md:29
msgid ""
"To integrate GLFW in your project, we first add its directory to our root"
" `CMakeLists.txt`:"
msgstr ""

#: ../../getting-started/opening-a-window.md:36
msgid ""
"The name 'glfw' here designate the directory where GLFW is located, so "
"there should be a file `glfw/CMakeLists.txt`. Otherwise it means that "
"`glfw.zip` was not decompressed in the correct directory; you may either "
"move it or adapt the `add_subdirectory` directive."
msgstr ""

#: ../../getting-started/opening-a-window.md:39
msgid ""
"Then, we must tell CMake to link our application to this library (after "
"`add_executable(App main.cpp)`):"
msgstr ""

#: ../../getting-started/opening-a-window.md:46
msgid ""
"This time, the name 'glfw' is one of the *target* defined in "
"`glfw/CMakeLists.txt` by calling `add_library(glfw ...)`, it is not "
"related to a directory name."
msgstr ""

#: ../../getting-started/opening-a-window.md:49
msgid ""
"You should now be able to build the application and add `#include "
"<GLFW/glfw3.h>` at the beginning of the main file."
msgstr ""

#: ../../getting-started/opening-a-window.md:56
msgid ""
"If you are on a linux system, make sure to install the package `xorg-"
"dev`, which GLFW depends on."
msgstr ""

#: ../../getting-started/opening-a-window.md:58
msgid "Basic usage"
msgstr ""

#: ../../getting-started/opening-a-window.md:61
msgid ""
"First of all, any call to the GLFW library must be between its "
"initialization and termination:"
msgstr ""

#: ../../getting-started/opening-a-window.md:69
msgid "The init function returns false when it could not setup things up:"
msgstr ""

#: ../../getting-started/opening-a-window.md:79
msgid "Once the library has been initialized, we may create a window:"
msgstr ""

#: ../../getting-started/opening-a-window.md:91
msgid "Here again, we may add some error management:"
msgstr ""

#: ../../getting-started/opening-a-window.md:102
msgid ""
"At this point, the window opens and closes immediately after. To address "
"this, we add the application's **main loop**:"
msgstr ""

#: ../../getting-started/opening-a-window.md:113
msgid ""
"This main loop is where most of the application's logic occurs. We will "
"repeatedly clear and redraw the whole image, and check for new user "
"input."
msgstr ""

#: ../../getting-started/opening-a-window.md:119
msgid "Our first window, using the GLFW library."
msgstr ""

#: ../../getting-started/project-setup.md:1
msgid "Project setup"
msgstr ""

#: ../../getting-started/project-setup.md:8
#: ../../getting-started/project-setup.md:150
msgid ""
"*Resulting code:* [`step000`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step000)"
msgstr ""

#: ../../getting-started/project-setup.md:10
msgid ""
"In our running example, we use [CMake](https://cmake.org/) to organize "
"the compilation of the code. This is a very standard way of handling "
"cross-platform builds, and we follow the idioms of [modern "
"cmake](https://cliutils.gitlab.io/modern-cmake/)."
msgstr ""

#: ../../getting-started/project-setup.md:12
msgid "Requirements"
msgstr ""

#: ../../getting-started/project-setup.md:15
msgid ""
"All we need is CMake and a C++ compiler, instructions are detailed below "
"per OS."
msgstr ""

#: ../../getting-started/project-setup.md:18
msgid ""
"After the installation, you can type `which cmake` (linux/macOS) or "
"`where cmake` (Windows) to see whether your command line finds the full "
"path to the `cmake` command. If not, make sure your `PATH` environment "
"variable contains the directory where CMake is installed."
msgstr ""

#: ../../getting-started/project-setup.md:21
msgid "Linux"
msgstr ""

#: ../../getting-started/project-setup.md:23
msgid ""
"If you are under an Ubuntu/Debian distribution, install the following "
"packages:"
msgstr ""

#: ../../getting-started/project-setup.md:29
msgid ""
"Other distributions have equivalent packages, make sure you have the "
"commands `cmake`, `make` and `g++` working."
msgstr ""

#: ../../getting-started/project-setup.md:31
msgid "Windows"
msgstr ""

#: ../../getting-started/project-setup.md:33
msgid ""
"Download and install CMake from [the download "
"page](https://cmake.org/download/). You may use either [Visual "
"Studio](https://visualstudio.microsoft.com/downloads/) or "
"[MinGW](https://www.mingw-w64.org/) as a compiler toolkit."
msgstr ""

#: ../../getting-started/project-setup.md:35
msgid "MacOS"
msgstr ""

#: ../../getting-started/project-setup.md:37
msgid ""
"You can install CMake using `brew install cmake`, and "
"[XCode](https://developer.apple.com/xcode/) to build the project."
msgstr ""

#: ../../getting-started/project-setup.md:39
msgid "Minimal project"
msgstr ""

#: ../../getting-started/project-setup.md:42
msgid ""
"The most minimal project consists then in a `main.cpp` source file, and a"
" `CMakeLists.txt` build file."
msgstr ""

#: ../../getting-started/project-setup.md:44
msgid "Let us start with the classic hello world in `main.cpp`:"
msgstr ""

#: ../../getting-started/project-setup.md:55
msgid ""
"In `CMakeLists.txt`, we specify that we want to create a *target* of type"
" *executable*, called \"App\" (this will also be the name of the "
"executable file), and whose source code is `main.cpp`:"
msgstr ""

#: ../../getting-started/project-setup.md:61
msgid ""
"CMake also expects at the beginning of `CMakeLists.txt` to know the "
"version of CMake the file is written for (minimum supported...your "
"version) and some information about the project:"
msgstr ""

#: ../../getting-started/project-setup.md:74
msgid "Building"
msgstr ""

#: ../../getting-started/project-setup.md:77
msgid ""
"We are now ready to build our minimal project. Open a terminal and go to "
"the directory where you have the `CMakeLists.txt` and `main.cpp` files:"
msgstr ""

#: ../../getting-started/project-setup.md:84
msgid ""
"From a Windows explorer window showing your project's directory, press "
"Ctrl+L, then type `cmd` and hit return. This opens a terminal in the "
"current directory."
msgstr ""

#: ../../getting-started/project-setup.md:87
msgid ""
"Let us now ask CMake to create the build files for our project. We ask it"
" to isolate the build files from our source code by placing them in a "
"*build/* directory with the `-B build` option. This is very much "
"recommended, in order to be able to easily distinguish these generated "
"files from the ones we manually wrote (a.k.a. the source files):"
msgstr ""

#: ../../getting-started/project-setup.md:93
msgid ""
"This creates the build files for either `make`, Visual Studio or XCode "
"depending on your system (you can use the `-G` options to force a "
"particular build system, see `cmake -h` for more info). To finally build "
"the program and generate the `App` (or `App.exe`) executable, you can "
"either open the generated Visual Studio or XCode solution, or type in the"
" terminal:"
msgstr ""

#: ../../getting-started/project-setup.md:99
msgid "Then run the resulting program:"
msgstr ""

#: ../../getting-started/project-setup.md:106
msgid "Recommended extras"
msgstr ""

#: ../../getting-started/project-setup.md:109
msgid ""
"We set up some properties of the target `App` by calling somewhere after "
"`add_executable` the `set_target_properties` command."
msgstr ""

#: ../../getting-started/project-setup.md:118
msgid ""
"The `CXX_STANDARD` property is set to 17 to mean that we require C++17 "
"(this will enable us to use some syntactic tricks later on, but is not "
"mandatory per se)."
msgstr ""

#: ../../getting-started/project-setup.md:120
msgid ""
"The `COMPILE_WARNING_AS_ERROR` is turned on as a good practice, to make "
"sure no warning is left ignored. Warnings are actually important, "
"especially when learning a new language/library. To make sure we even "
"have as many warnings as possible, we add some compile options:"
msgstr ""

#: ../../getting-started/project-setup.md:131
msgid ""
"In the accompanying code, I hid these details in the "
"`target_treat_all_warnings_as_errors()` function defined in `utils.cmake`"
" and included at the beginning of the `CMakeLists.txt`."
msgstr ""

#: ../../getting-started/project-setup.md:134
msgid ""
"On MacOS, CMake can generate XCode project files. However, by default, no"
" *schemes* are created, and XCode itself generates a scheme for each "
"CMake target -- usually we only want a scheme for our main target. "
"Therefore, we set the `XCODE_GENERATE_SCHEME` property. We will also "
"already enable frame capture for GPU debugging."
msgstr ""

#: ../../getting-started/project-setup.md:148
msgid ""
"We now have a good basic project configuration, that we'll build upon in "
"the next chapters. We are ready to move on to opening a window."
msgstr ""

#: ../../getting-started/the-adapter.md:1
msgid "The Adapter"
msgstr ""

#: ../../getting-started/the-adapter.md:10
#: ../../getting-started/the-adapter.md:382
msgid ""
"*Resulting code:* [`step010`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step010)"
msgstr ""

#: ../../getting-started/the-adapter.md:12
msgid "Requesting the adapter"
msgstr ""

#: ../../getting-started/the-adapter.md:15
msgid ""
"The first thing we need to do in order to dialog with our GPU is to get a"
" WebGPU **adapter**. It is the main entry point of the library, and the "
"same host system may expose multiple adapters if it has multiple "
"implementations of the WebGPU backend (e.g., a high performance one, a "
"low energy consumption one, etc.)."
msgstr ""

#: ../../getting-started/the-adapter.md:17
msgid "In JavaScript, this would be:"
msgstr ""

#: ../../getting-started/the-adapter.md:24
msgid ""
"The equivalent in the C API is a bit more complex because there is no "
"such thing as [promises](https://developer.mozilla.org/en-"
"US/docs/Web/JavaScript/Reference/Global_Objects/Promise) in C, but the "
"logic is very similar."
msgstr ""

#: ../../getting-started/the-adapter.md:26
msgid "Without the `await` keyword, the JavaScript version can be rewritten as:"
msgstr ""

#: ../../getting-started/the-adapter.md:35
msgid "which is close enough to the C/C++ version (minus the boilerplate):"
msgstr ""

#: ../../getting-started/the-adapter.md:55
msgid ""
"The names of the procedure provided by `webgpu.h` always follow the same "
"construction:"
msgstr ""

#: ../../getting-started/the-adapter.md:64
msgid ""
"The first argument of the function is always a \"handle\" (a blind "
"pointer) representing an object of type \"Something\"."
msgstr ""

#: ../../getting-started/the-adapter.md:67
msgid "Request"
msgstr ""

#: ../../getting-started/the-adapter.md:69
msgid ""
"We can wrap this in a `requestAdapter()` function that mimicks the JS "
"`await requestAdapter()`:"
msgstr ""

#: ../../getting-started/the-adapter.md:127
msgid "In the main function, after opening the window, we can get the adapter:"
msgstr ""

#: ../../getting-started/the-adapter.md:138
msgid "Destruction"
msgstr ""

#: ../../getting-started/the-adapter.md:140
msgid "Like for the WebGPU instance, we must destroy the adapter:"
msgstr ""

#: ../../getting-started/the-adapter.md:185
msgid "The Surface"
msgstr ""

#: ../../getting-started/the-adapter.md:194
msgid ""
"We actually need to pass an option to the adapter request: the "
"**surface** onto which we draw."
msgstr ""

#: ../../getting-started/the-adapter.md:206
msgid ""
"How do we get the surface? This depends on the OS, and GLFW does not "
"handle this for us, for it does not know WebGPU (yet?). So I provide you "
"this function, in a little extension to GLFW3 called "
"[`glfw3webgpu`](https://github.com/eliemichel/glfw3webgpu)."
msgstr ""

#: ../../getting-started/the-adapter.md:208
msgid "GLFW3 WebGPU Extension"
msgstr ""

#: ../../getting-started/the-adapter.md:210
msgid ""
"Download and unzip "
"[glfw3webgpu.zip](https://github.com/eliemichel/glfw3webgpu/releases/download/v1.0.1/glfw3webgpu-v1.0.1.zip)"
" in your project's directory. There should now be a directory "
"`glfw3webgpu` sitting next to your `main.cpp`. Like we have done before, "
"we can add this directory and link the target it creates to our App:"
msgstr ""

#: ../../getting-started/the-adapter.md:222
msgid ""
"The `glfw3webgpu` library is very simple, it is only made of 2 files so "
"we could have almost included them directly in our project's source tree."
" However, it requires some special compilation flags in macOS that we "
"would have had to deal with (you can see them in the `CMakeLists.txt`)."
msgstr ""

#: ../../getting-started/the-adapter.md:225
msgid ""
"You can now `#include <glfw3webgpu.h>` at the beginning of your "
"`main.cpp` and get the surface by simply doing:"
msgstr ""

#: ../../getting-started/the-adapter.md:235
msgid "Also don't forget to release the texture at the end:"
msgstr ""

#: ../../getting-started/the-adapter.md:247
msgid ""
"One last thing: we can **tell GLFW not to care about the graphics API** "
"setup, as it does not know WebGPU and we won't use what it could set up "
"by default for other APIs:"
msgstr ""

#: ../../getting-started/the-adapter.md:268
msgid ""
"The `glfwWindowHint` function is a way to pass optional arguments to "
"`glfwCreateWindow`. Here we tell it to initialize no particular graphics "
"API by default, as we manage this ourselves."
msgstr ""

#: ../../getting-started/the-adapter.md:271
msgid ""
"I invite you to look at the documentation of GLFW to know more about "
"[`glfwCreateWindow`](https://www.glfw.org/docs/latest/group__window.html#ga3555a418df92ad53f917597fe2f64aeb)"
" and other related functions."
msgstr ""

#: ../../getting-started/the-adapter.md:274
msgid "Inspecting the adapter"
msgstr ""

#: ../../getting-started/the-adapter.md:277
msgid ""
"The adapter object provides **information about the underlying "
"implementation** and hardware, and about what it is able or not to do."
msgstr ""

#: ../../getting-started/the-adapter.md:279
msgid ""
"Let us focus on the `wgpuAdapterEnumerateFeatures` function, which "
"enumerates the features of the WebGPU implementation, because its usage "
"is very typical from WebGPU native."
msgstr ""

#: ../../getting-started/the-adapter.md:281
msgid ""
"We call the function **twice**. The **first time**, we provide a null "
"pointer as the return, and as a consequence the function only returns the"
" **number of features**, but not the features themselves."
msgstr ""

#: ../../getting-started/the-adapter.md:283
msgid ""
"We then dynamically **allocate memory** for storing this many items of "
"result, and call the same function a **second time**, this time with a "
"pointer to where the result should store its result."
msgstr ""

#: ../../getting-started/the-adapter.md:318
msgid ""
"The features are numbers corresponding to the enum `WGPUFeatureName` "
"defined in `webgpu.h`."
msgstr ""

#: ../../getting-started/the-adapter.md:320
msgid ""
"You may notice very high numbers apparently not defined in this enum. "
"These are **extensions** provided by our native implementation (e.g., "
"defined in `wgpu.h` instead of `webgpu.h` in the case of `wgpu-native`)."
msgstr ""

#: ../../getting-started/the-adapter.md:323
msgid ""
"In the accompanying code, extra information retrieval is exemplified in "
"the `inspectAdapter()` function. Look in `webgpu.h` for function that "
"starts with `wgpuAdapter` to find other adapter methods."
msgstr ""

#: ../../getting-started/the-adapter.md:377
msgid "The very first thing to do with WebGPU is to get the **adapter**."
msgstr ""

#: ../../getting-started/the-adapter.md:378
msgid ""
"This adapter can have **options**, in particular the **surface** on which"
" it draws."
msgstr ""

#: ../../getting-started/the-adapter.md:379
msgid ""
"To get a WebGPU surface from our GLFW window, we use a small **extension "
"of GLFW** called `glfw3webgpu`."
msgstr ""

#: ../../getting-started/the-adapter.md:380
msgid "Once we have an adapter, we can inspect its **capabilities**."
msgstr ""

#: ../../getting-started/the-command-queue.md:1
msgid "The Command Queue"
msgstr ""

#: ../../getting-started/the-command-queue.md:9
#: ../../getting-started/the-command-queue.md:196
msgid ""
"*Resulting code:* [`step017`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step017)"
msgstr ""

#: ../../getting-started/the-command-queue.md:11
msgid ""
"We are getting close, but we will still not display anything on our "
"window. We learn in this chapter a key concept of WebGPU (and of most "
"modern graphics APIs as well): the **command queue**."
msgstr ""

#: ../../getting-started/the-command-queue.md:16
msgid ""
"The CPU instructs the GPU what to do by sending commands through a "
"command queue."
msgstr ""

#: ../../getting-started/the-command-queue.md:19
msgid "Different timelines"
msgstr ""

#: ../../getting-started/the-command-queue.md:22
msgid ""
"One thing important to keep in mind when doing graphics programming: we "
"have **two processors running simultaneously**. One of them is the CPU, "
"also known as *host*, and the other one is the GPU, or *device*. There "
"are two rules:"
msgstr ""

#: ../../getting-started/the-command-queue.md:24
msgid ""
"**The code we write runs on the CPU**, and some of it triggers operations"
" on the GPU. The only exception are *shaders*, which actually run on GPU."
msgstr ""

#: ../../getting-started/the-command-queue.md:25
msgid ""
"Processors are \"**far away**\", meaning that communicating between them "
"takes time."
msgstr ""

#: ../../getting-started/the-command-queue.md:27
msgid ""
"They are not too far, but for high performance applications like real "
"time graphics, this matters. In advanced pipelines, rendering a frame may"
" involve thousands or tens of thousands of commands running on the GPU."
msgstr ""

#: ../../getting-started/the-command-queue.md:29
msgid ""
"As a consequence, we cannot afford to send the commands one by one from "
"the CPU and wait for a response after each one. Instead, commands meant "
"to the GPU are batched and fired through a **command queue**. The GPU "
"consumes this queue whenever it is ready, and this way processors "
"minimize the time spend idling for their sibling to respond."
msgstr ""

#: ../../getting-started/the-command-queue.md:31
msgid ""
"The CPU-side of your program, i.e., the C++ code that you write, lives in"
" the **Content timeline**. The other side of the command queue is the "
"**Queue timeline**, running on the GPU."
msgstr ""

#: ../../getting-started/the-command-queue.md:34
msgid ""
"There is also a **Device timeline** defined in [WebGPU's "
"documentation](https://www.w3.org/TR/webgpu/#programming-model-"
"timelines). It corresponds to the GPU operations for which our code "
"actually waits for an immediate answer (called \"synchronous\" calls), "
"but unlike the JavaScript API, it is roughly the same as the content "
"timeline in our C++ case."
msgstr ""

#: ../../getting-started/the-command-queue.md:37
msgid "Queue operations"
msgstr ""

#: ../../getting-started/the-command-queue.md:40
msgid ""
"Our WebGPU device has a single queue, which we can get with "
"`wgpuDeviceGetQueue`."
msgstr ""

#: ../../getting-started/the-command-queue.md:47
msgid ""
"Other graphics API allow one to build multiple queues per device, and "
"future version of WebGPU might as well. But for now, one queue is already"
" more than enough for us to play with!"
msgstr ""

#: ../../getting-started/the-command-queue.md:50
msgid ""
"Looking at `webgpu.h`, we find 3 different ways to submit work to this "
"queue:"
msgstr ""

#: ../../getting-started/the-command-queue.md:52
msgid "`wgpuQueueSubmit`"
msgstr ""

#: ../../getting-started/the-command-queue.md:53
msgid "`wgpuQueueWriteBuffer`"
msgstr ""

#: ../../getting-started/the-command-queue.md:54
msgid "`wgpuQueueWriteTexture`"
msgstr ""

#: ../../getting-started/the-command-queue.md:56
msgid ""
"The first one only sends commands (potentially complicated ones though), "
"and the two other ones send memory from the CPU memory (RAM) to the GPU "
"one (VRAM). This is where the delay of the communication might become "
"particularly critical."
msgstr ""

#: ../../getting-started/the-command-queue.md:58
msgid ""
"We also find a `wgpuQueueOnSubmittedWorkDone` procedure that we can use "
"to set up a function to be called back once the work is done. Let us do "
"it to make sure things happen as expected:"
msgstr ""

#: ../../getting-started/the-command-queue.md:78
msgid "Submitting commands"
msgstr ""

#: ../../getting-started/the-command-queue.md:81
msgid "We submit commands using the following procedure:"
msgstr ""

#: ../../getting-started/the-command-queue.md:87
msgid ""
"We see **a typical idiom** here: WebGPU is a C API so whenever it needs "
"to receive an array of things, we first provide the array size then a "
"pointer to the first element."
msgstr ""

#: ../../getting-started/the-command-queue.md:89
msgid "If we have a single element, it is simply:"
msgstr ""

#: ../../getting-started/the-command-queue.md:97
msgid ""
"If we know at compile time (\"statically\") the number of commands, we "
"may use a C array (although a `std::array` is safer):"
msgstr ""

#: ../../getting-started/the-command-queue.md:115
msgid "And if we need to dynamically change the size, we use a `std::vector`:"
msgstr ""

#: ../../getting-started/the-command-queue.md:123
msgid ""
"However, we **cannot manually create** a `WGPUCommandBuffer` object. This"
" buffer uses a special format that is left to the discretion of your "
"driver/hardware. To build this buffer, we use a **command encoder**."
msgstr ""

#: ../../getting-started/the-command-queue.md:125
msgid "Command encoder"
msgstr ""

#: ../../getting-started/the-command-queue.md:128
msgid ""
"A command encoder is created following the usual object creation idiom of"
" WebGPU:"
msgstr ""

#: ../../getting-started/the-command-queue.md:137
msgid ""
"We can now use the encoder to write instructions (debug placeholder for "
"now)."
msgstr ""

#: ../../getting-started/the-command-queue.md:144
msgid ""
"And then finally generating the command from the encoder also requires an"
" extra descriptor:"
msgstr ""

#: ../../getting-started/the-command-queue.md:174
msgid "This should output:"
msgstr ""

#: ../../getting-started/the-command-queue.md:181
msgid ""
"At this stage, the code works, but submits a command queue that is almost"
" empty. So it is a bit hard to be thrilled about, let's pump it up with "
"some basic buffer manipulation."
msgstr ""

#: ../../getting-started/the-command-queue.md:186
msgid "We have seen a few important notions in this chapter:"
msgstr ""

#: ../../getting-started/the-command-queue.md:188
msgid "The CPU and GPU live in **different timelines**."
msgstr ""

#: ../../getting-started/the-command-queue.md:189
msgid "Commands are streamed from CPU to GPU through a **command queue**."
msgstr ""

#: ../../getting-started/the-command-queue.md:190
msgid "Queued command buffers must be encoded using a **command encoder**."
msgstr ""

#: ../../getting-started/the-command-queue.md:192
msgid ""
"This was a bit abstract because we can queue operations but we did not "
"see any yet. In the next chapter we use it to **finally display "
"something** in our window!"
msgstr ""

#: ../../getting-started/the-command-queue.md:194
msgid ""
"We will also see in [*Playing with buffers*](../basic-3d-rendering/input-"
"geometry/playing-with-buffers.md) how to use it for GPU-side buffer "
"manipulation."
msgstr ""

#: ../../getting-started/the-device.md:1
msgid "The Device"
msgstr ""

#: ../../getting-started/the-device.md:9
#: ../../getting-started/the-device.md:238
msgid ""
"*Resulting code:* [`step015`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step015)"
msgstr ""

#: ../../getting-started/the-device.md:11
msgid ""
"A WebGPU **device** represents a **context** of use of the API. All the "
"objects that we create (geometry, textures, etc.) are owned by the "
"device."
msgstr ""

#: ../../getting-started/the-device.md:13
msgid "ðŸ¤” Why do we have both an **adapter** and then a **device** abstraction?"
msgstr ""

#: ../../getting-started/the-device.md:15
msgid ""
"The idea is to limit the \"it worked on my machine\" issue you could "
"encounter when trying your program on a different machine. The "
"**adapter** is used to **access the capabilities** of the customer's "
"hardware, which are used to select the behavior of your application among"
" very different code paths. Once a code path is chosen, a **device** is "
"created with **the capabilities we choose**."
msgstr ""

#: ../../getting-started/the-device.md:17
msgid ""
"Only the capabilities selected for this device are then allowed in the "
"rest of the application. This way, it is **not possible to inadvertently "
"rely on capabilities specific to your own machine**."
msgstr ""

#: ../../getting-started/the-device.md:21
msgid ""
"In an advanced use of the adapter/device duality, we can set up multiple "
"limit presets and select one depending on the adapter. In our case, we "
"have a single preset and abort early if it is not supported."
msgstr ""

#: ../../getting-started/the-device.md:24
msgid "Device request"
msgstr ""

#: ../../getting-started/the-device.md:27
msgid ""
"Requesting the device looks a lot like requesting the adapter, so we will"
" use a very similar function:"
msgstr ""

#: ../../getting-started/the-device.md:72
msgid ""
"In the accompanying code, I moved these utility functions into `webgpu-"
"utils.cpp`"
msgstr ""

#: ../../getting-started/the-device.md:142
msgid ""
"In the main function, after getting the adapter, we can request the "
"device:"
msgstr ""

#: ../../getting-started/the-device.md:159
msgid "And before destroying the adapter, we release the device:"
msgstr ""

#: ../../getting-started/the-device.md:165
msgid "Device descriptor"
msgstr ""

#: ../../getting-started/the-device.md:168
msgid "Let us look in `webgpu.h` what the descriptor looks like:"
msgstr ""

#: ../../getting-started/the-device.md:187
msgid "For now we will initialize this to a very minimal option:"
msgstr ""

#: ../../getting-started/the-device.md:198
msgid ""
"We will come back here and refine these options whenever we will need "
"some more capabilities from the device."
msgstr ""

#: ../../getting-started/the-device.md:201
msgid ""
"The `label` is **used in error message** to help you debug where "
"something went wrong, so it is good practice to use it as soon as you get"
" multiple objects of the same type. Currently, this is only used by Dawn."
msgstr ""

#: ../../getting-started/the-device.md:204
msgid "Device error callback"
msgstr ""

#: ../../getting-started/the-device.md:207
msgid ""
"Before moving on to the next section, I would like you to add this call "
"after creating the device:"
msgstr ""

#: ../../getting-started/the-device.md:218
msgid ""
"This defines **a callback that gets executed upon errors**, which is very"
" handy for debugging, especially when we will start using "
"**asynchronous** operations."
msgstr ""

#: ../../getting-started/the-device.md:220
msgid ""
"If you use a debugger (which I recommend), like `gdb` or your IDE, I "
"recommend you **put a breakpoint** in this callback, so that your program"
" pauses and provides you with a call stack whenever WebGPU encounters an "
"unexpected error."
msgstr ""

#: ../../getting-started/the-device.md:223
msgid ""
"By default Dawn runs callbacks only when the device \"ticks\", so the "
"error callbacks are invoked in a different call stack than where the "
"error occurred, making the breakpoint less informative. To force Dawn to "
"invoke error callbacks as soon as there is an error, you can set the "
"environment variable `DAWN_DEBUG_BREAK_ON_ERROR` to a non-empty non-zero "
"value."
msgstr ""

#: ../../getting-started/the-device.md:225
msgid ""
"To automatically set this up in Visual Studio from CMake, you can add the"
" following to your `CMakeLists.txt`:"
msgstr ""

#: ../../getting-started/the-device.md:231
msgid ""
"Note that **this feature is imperfect** and sometimes breaks in non-error"
" cases. This [has been "
"reported](https://bugs.chromium.org/p/dawn/issues/detail?id=1789&q=&can=4),"
" in the meantime just press \"Continue\" in your IDE when this happens."
msgstr ""

#: ../../getting-started/the-device.md:234
msgid "Dawn again"
msgstr ""

#: ../../getting-started/the-device.md:235
msgid ""
"Dawn will show a warning about a missing **device lost callback**. You "
"may set it in a very similar way than the error callback, except as of "
"now (2023-07-04) the API is different in the official `webgpu.h` header, "
"so I won't add it until this is settled."
msgstr ""

